/**
 * FastFlameFractals (FFF)
 * A library for rendering flame fractals asynchronously using Java and OpenCL.
 *
 * Copyright (c) 2015 Jeremiah N. Hankins
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package fff.render;

import fff.flame.Flame;
import java.awt.image.BufferedImage;

/**
 * {@code RendererUpdate} contains update information/output generated by 
 * {@link FlameRenderer}.
 * 
 * @author Jeremiah N. Hankins
 */
public class RendererUpdate {
    /**
     * The renderer that generated this update.
     */
    protected FlameRenderer renderer;
    
    /**
     * The task that generated this update.
     */
    protected RendererTask task;

    /**
     * The flame that generated this update.
     */
    protected Flame flame; 

    /**
     * The current image. May be {@code null} if {@link FlameRenderer#getUpdateImages()} is
     * {@code false}.
     */
    protected BufferedImage image;

    /**
     * The "quality" of the image. The quality is equal to the total number
     * of points plotted divided by the number of pixels plotted to while
     * rendering the image.
     */
    protected double quality; 

    /**
     * The total number of points plotted to generate the image.
     */
    protected double points;

    /**
     * The amount of time in seconds that the {@code FlameRenderer} has
     * spent working on the image.
     */
    protected double elapsedTime; 

    /**
     * If {@code true} if the image of the flame is complete. If
     * {@code false} then the image is still being worked on.
     */
    protected boolean isFinished;

    /**
     * Returns the {@link FlameRenderer} that generated this update.
     * 
     * @return the renderer that generated this update
     */
    public FlameRenderer getRenderer() {
        return renderer;
    }
    
    /**
     * Returns the {@link RendererTask} that generated this update.
     * 
     * @return the task that generated this update
     */
    public RendererTask getTask() {
        return task;
    }

    /**
     * Returns the {@link Flame} that generated this update.
     * 
     * @return the flame that generated this update
     */
    public Flame getFlame() {
        return flame;
    }

    /**
     * Returns the current image of the flame.
     * The returned value will be {@code null} if {@link #isFinished()} and
     * {@link FlameRenderer#getUpdateImages()} are both {@code false}.
     * 
     * @return the current image of the flame
     */
    public BufferedImage getImage() {
        return image;
    }
    
    /**
     * Returns the quality image. The quality is equal to the total number of
     * points plotted by the renderer produce the image divided by the number of
     * pixels in the image that have been plotted to (a single pixels is counted
     * at most once even if it is plotted to more than once).
     * 
     * @return the quality of the image
     */
    public double getQuality() {
        return quality;
    }
    
    /**
     * Returns the total number of points plotted by the renderer to produce the
     * image. This value can be used to calculate the number points plotted per
     * second which can be used as a benchmarking metric.
     * 
     * @return the number of points plotted by the renderer to produce the image
     */
    public double getPoints() {
        return points;
    }
    
    /**
     * Returns the duration of time in seconds that the renderer had spent
     * working on the image when this update was generated.
     * 
     * @return the duration of time in seconds that was spent working on the image
     */
    public double getElapsedTime() {
        return elapsedTime;
    }
    
    /**
     * Returns {@code true} if the image has is complete and the renderer is
     * done working on the current flame.
     * 
     * @return {@code true} if the flame's image is complete
     */
    public boolean isFinished() {
        return isFinished;
    }
    
    @Override
    public String toString() {
        return String.format("Drawn %.2fM dots in %.2f sec at %.2fM dots/sec for quality of %.2f.", points/1e7, elapsedTime, points/(1e7*elapsedTime), quality);
    }       
}